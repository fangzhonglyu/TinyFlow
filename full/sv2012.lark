start: description*

?description: module
            | MACRO

//=============================================================================
// Module Headers Syntax
//=============================================================================

// Module Definition
module: "module" ID param_decl_list? port_decl_list? ";" _top_blocks* "endmodule"

// Module Port Parameters
param_decl_list: "#" "(" param_decl* ")"
param_decl: ("parameter"|"localparam") opt_decl

// Module Port Declarations
port_decl_list: "(" port_decl* ")"
!port_decl: ("input" | "output") opt_decl

// Array/Array Slicing Syntax
dim: "[" expr ":" expr "]"
   | "[" expr "]"

_top_blocks: proc_block
           | instance
           | assignment
           | decl
           | localparam


localparam: ("parameter"|"localparam") opt_decl "=" expr ";"
opt_decl: DTYPE? dim* ID dim* ("=" expr)?
decl: DTYPE dim* ID+ dim*  ("=" expr)? ";"

//=============================================================================
// Procedural Blocks
//=============================================================================

proc_block: "always_comb" _block                            -> always_comb
          | ("always_ff" | "always") sensitivity _block     -> always_ff
          | "always_latch" sensitivity _block               -> always_latch
          | "always" 

sensitivity: "@" "(" _events ")"

_events: "*"
       | event (("," | "or") event)*
      
?event: "posedge" expr -> posedge
       | "negedge" expr -> negedge
       | expr

//=============================================================================
// Module Instantiation
//=============================================================================

instance: ID ("#" _conn_list)? ID _conn_list? ";"

_conn_list: "(" conns ")"
conns: conn* auto_conn? -> conn_by_name
     | expr*            -> conn_by_order

auto_conn: ".*"
conn: "." ID "(" expr? ")"

//=============================================================================
// Assignment Syntax
//=============================================================================

assignment: "assign" lvalue "=" expr ";"

lvalue: ID 
      | lvalue dim

//=============================================================================
// Statement and Block Syntax
//=============================================================================

_block: "begin" (":" ID)? _block* "end"
     | stmt

stmt: "if" "(" expr ")" _block ("else" _block)? -> if
    | lvalue "<=" expr ";" -> seq
    | lvalue "="  expr ";" -> blk

//=============================================================================
// Expression Syntax (Any value)
//=============================================================================

// Operator Precedence (Descending)
// 1. Bit select
// 2. Parentheses
// 3. Unary logical/reduction operators
// 4. Unary pos/neg operators
// 5. Concatenation
// 6. Replication
// 7. Power
// 7. Multiplication, division, modulo
// 8. Addition, subtraction
// 9. Shift operators
// 10. Comparison operators
// 11. Logical equality operators
// 12. Case equality operators
// 13. Bitwise AND
// 14. Bitwise XOR/XNOR
// 15. Bitwise OR
// 16. Logical AND
// 17. Logical OR
// 18. Ternary operator

expr: ternary

?ternary: log_and "?" log_and ":" log_and
        | log_and

?log_and: log_and "&&" log_or
        | log_or

?log_or: log_or "||" bit_or
       | bit_or

?bit_or: bit_or "|" bit_xor
       | bit_xor

?bit_xor: bit_xor "^"  bit_and
        | bit_xor "~^" bit_and -> bit_xnor
        | bit_and

?bit_and: bit_and  "&" case_eq -> bit_and
        | bit_and "~&" case_eq -> bit_nand
        | case_eq

?case_eq: case_eq "===" eq -> ceq
        | case_eq "!==" eq -> cne
        | eq

?eq: eq "==" comp -> eq
   | eq "!=" comp -> ne
   | comp

?comp: comp "<"  shift -> lt
     | comp "<=" shift -> le
     | comp ">"  shift -> gt
     | comp ">=" shift -> ge
     | shift

?shift: shift "<<"  sum -> sla
      | shift ">>"  sum -> sra
      | shift ">>>" sum -> sll
      | shift "<<<" sum -> srl
      | sum

?sum: sum "+" product -> add
    | sum "-" product -> sub
    | product

?product: product "*" atom -> mul
        | product "/" atom -> div
        | product "%" atom -> mod
        | atom

?atom: atom "**" exponent -> pow
       | exponent

?exponent: "{" replica "{" replica "}" "}" -> rep
         | replica

?replica: "{" expr+ "}" -> cat
        | part

?part: "+" part -> pos
     | "-" part -> neg
     | unary

?unary: "!"  unary -> not
      | "~"  unary -> neg
      | "&"  unary -> reduce_and
      | "|"  unary -> reduce_or
      | "^"  unary -> reduce_xor
      | "~&" unary -> reduce_nand
      | "~|" unary -> reduce_nor
      | "~^" unary -> reduce_xnor
      | group

?group: "(" expr ")"
      | "$clog2(" expr ")" -> clog2
      | "$signed(" expr ")" -> signed
      | "$unsigned(" expr ")" -> unsigned
      | "int'(" expr ")" -> cast_int
      | slice

slice: VAR dim*
      | LITERAL
       

// Identifiers
VAR: CLEANED_STR
   | "`" CLEANED_STR

ID: CLEANED_STR
  | "`" CLEANED_STR

CLEANED_STR: /(?!logic\b)(?!int\b)(?!integer\b)(?!wire\b)(?!reg\b)(?!unsigned\b)(?!signed\b)[a-zA-Z_][a-zA-Z0-9_]*/


// Data Types

DTYPE: ("reg" | "wire" | "integer" | "int" | "logic") WS ("signed" | "unsigned")?

// Literals
LITERAL: INT
       | INT "'b" BIN
       | INT "'o" OCT
       | INT "'d" DEC
       | INT "'h" HEX

BIN: /[01zx]+/
OCT: /[0-7]+/
DEC: /[0-9]+/
HEX: /[0-9a-fA-F]+/

// Token Definitions
ESCAPED_IDENTIFIER: /\\([^\s]+)/
COMMENT: "//" /[^\n]*/ NEWLINE
NEWLINE: "\n"
MULTILINE_COMMENT: /\/\*(\*(?!\/)|[^*])*\*\//
MACRO: "`" CNAME /[^\n]*/ NEWLINE

%import common.CNAME
%import common.ESCAPED_STRING
%import common.WS
%import common.INT

%ignore WS
%ignore COMMENT
%ignore MULTILINE_COMMENT
%ignore NEWLINE
%ignore ","